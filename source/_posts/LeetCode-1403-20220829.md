---
title: 【LeetCode每日一题】1403.非递增顺序的最小子序列
categories: 'LeetCode每日一题'
tags: 
  - LeetCode
  - Algorithm
katex: true
---
> 题目链接：https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/
>
> 题目难度：简单

### 题意

给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。

**示例1：**

```
输入：nums = [4,3,10,9,8]
输出：[10,9] 
解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。
```

**示例2：**

```
输入：nums = [4,4,7,6,7]
输出：[7,7,6] 
解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。  
```

**示例3：**

```
输入：nums = [6]
输出：[6]
```

**提示：**

- `1 <= nums.length <= 500`
- `1 <= nums[i] <= 100`

### 题解：贪心+前缀和

题目只需要求符合条件的子序列，同时最终结果需要返回**非递增顺序（即：从大到小排列）**

于是不妨直接对数组排序，然后依次从大到小选择元素，设两个集合：

- 一个表示最终选取的元素集合，设其元素和为sum
- 一个表示剩余的元素集合，其元素和可以通过前缀和计算

只要选取的元素集合总和大于剩余元素集合的和，则结束遍历，直接输出选取的元素集合即可。

#### C++代码1：

```cpp
class Solution {
public:
    vector<int> minSubsequence(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size();
        int pre_sum[n+1];pre_sum[0]=nums[0];
        for(int i=1;i<n;i++) pre_sum[i]=pre_sum[i-1]+nums[i];
        vector<int> ans;
        int sum=0;
        ans.push_back(nums[n-1]);sum=nums[n-1];
        for(int i=n-2;i>=0;i--){
            if(sum>pre_sum[i]){
                break;
            }
            sum+=nums[i];ans.push_back(nums[i]);
        }
        return ans;
    }
};
```

当然还可以优化，无需前缀和，直接用一个变量存储所有元素的和，然后依次减去选取的元素即可。

#### C++代码2：

```cpp
class Solution {
public:
    vector<int> minSubsequence(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size(),total_sum=0;
        for(int i=0;i<n;i++) total_sum+=nums[i];
        vector<int> ans;
        int sum=0;
        for(int i=n-1;i>=0;i--){
            sum+=nums[i];ans.push_back(nums[i]);total_sum-=nums[i];
            if(sum>total_sum){
                break;
            }
        }
        return ans;
    }
};
```
