---
title: 【LeetCode每日一题】899.有序队列
categories: 'LeetCode每日一题'
tags: 
  - LeetCode
  - Algorithm
katex: true
---
> 题目链接：https://leetcode.cn/problems/orderly-queue/
>
> 题目难度：困难

### 题意

给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。

返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。

**示例 1：**

```
输入：s = "cba", k = 1
输出："acb"
解释：
在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
```

**示例 2：**

```
输入：s = "baaca", k = 3
输出："aaabc"
解释：
在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
```

**提示：**

- `1 <= k <= S.length <= 1000`
- s 只由小写字母组成。

### 题解：数学

分类讨论。根据题意可以简单划分为$k=1$和$k\gt1$两种情况

- $k=1$，即依次将所有元素插入到字符串最后，选择这n个字符串中字典序最小的那个
- $k\gt1$，可以通过数学证明，通过若干次操作后能将当前字符串转化为与之对应的字典序最小的字符串。至于如何获得字典序最小的字符串：直接对该字符串从小到大排序即可。（具体数学证明见官方题解：https://leetcode.cn/problems/orderly-queue/solution/you-xu-dui-lie-by-leetcode-solution-p6gv/）

#### C++代码：

```cpp
class Solution {
public:
    string orderlyQueue(string s, int k) {
        if(k==1){
            int n=s.length();
            string min_str=s;
            for(int i=0;i<n;i++){
                char c=s[0];
                s=s.substr(1);
                s+=c;
                min_str=min(min_str,s);
            }
            return min_str;
        }else{
            sort(s.begin(),s.end());
            return s;
        }
    }
};
```
