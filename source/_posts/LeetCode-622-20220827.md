---
title: 【LeetCode每日一题】662.二叉树最大宽度
categories: 'LeetCode每日一题'
tags: 
  - LeetCode
  - Algorithm
katex: true
---
> 题目链接：https://leetcode.cn/problems/maximum-width-of-binary-tree/
>
> 题目难度：中等

<!-- more -->

### 题意

给你一棵二叉树的根节点 root ，返回树的 最大宽度 。

树的 最大宽度 是所有层中最大的 宽度 。

每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。

题目数据保证答案将会在  32 位 带符号整数范围内。

**示例1：**

![width1-tree-2022-09-11-17-47-53](http://lbbuket-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/width1-tree-2022-09-11-17-47-53.jpg/resize80)

```
输入：root = [1,3,2,5,3,null,9]
输出：4
解释：最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。
```

**示例2：**

![maximum-width-of-binary-tree-v3-2022-09-11-17-48-39](http://lbbuket-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/maximum-width-of-binary-tree-v3-2022-09-11-17-48-39.jpg/resize80)

```
输入：root = [1,3,2,5,null,null,9,6,null,7]
输出：7
解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
```

**示例3：**

![20220911201958-2022-09-11-20-19-58](http://lbbuket-blog.oss-cn-hangzhou.aliyuncs.com/blog-img/20220911201958-2022-09-11-20-19-58.png/resize80)

```
输入：root = [1,3,2,5]
输出：2
解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。
```

**提示：**

- 树中节点的数目范围是 `[1, 3000]`
- `-100 <= Node.val <= 100`

### 题解：dfs

二叉树我们熟知一个性质：**当某一个节点索引为index时，它的左孩子索引为$2*index$，它的右孩子为$2*index+1$**

于是直接遍历整棵二叉树，对于每一层都求得它的宽度，然后对比计算最大的宽度即可。

然而每一层的宽度为：最后一个节点的索引-第一个节点的索引+1

可以用二维数组存储每一层的所有节点索引，也可以直接在遍历时不断更新最终结果。为方便起见，此处采用的是使用二维数组存储每一层的节点索引。需要注意会爆int

#### C++代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    typedef long long ll;
    vector<ll> dep_nodes[3005];
    int max_depth=0;
    void dfs(TreeNode* root,int depth,ll pos){
        if(root==nullptr) return ;
        max_depth=max(max_depth,depth);
        dep_nodes[depth].push_back(pos);
        dfs(root->left,depth+1,2*pos);
        dfs(root->right,depth+1,2*pos+1);
    }
    int widthOfBinaryTree(TreeNode* root) {
        memset(dep_nodes,0,sizeof(dep_nodes));
        max_depth=0;
        dfs(root,0,1);
        ll ans=0;
        for(int i=0;i<=max_depth;i++){
            int n=dep_nodes[i].size();
            ans=max(ans,dep_nodes[i][n-1]-dep_nodes[i][0]+1);
        }
        return ans;
    }
};
```
